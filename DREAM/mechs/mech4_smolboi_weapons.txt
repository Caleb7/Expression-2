########################################
# Exported by Dream's Hologram Modeler
# Date: 12/23/2019 @ 198
# Holograms: 123
########################################
@name mech4_smolboi_weapons
@outputs Fire
@persist Hologram:table [ Seat Driver Entity Body ]:entity
@persist [ FR_P1 FR_P2 FR_P3 ]:vector FR_STEP:number FR_STEP_SOUND:number FR_XRD:ranger
@persist [ FL_P1 FL_P2 FL_P3 ]:vector FL_STEP:number FL_STEP_SOUND:number FL_XRD:ranger
@persist [ RR_P1 RR_P2 RR_P3 ]:vector RR_STEP:number RR_STEP_SOUND:number RR_XRD:ranger
@persist [ RL_P1 RL_P2 RL_P3 ]:vector RL_STEP:number RL_STEP_SOUND:number RL_XRD:ranger
@persist [ SPEED SHIFTSPEED LEGSPEED STEPDAMP STEPARCH LEGINCREMENT BODYHEIGHT MAX_OVERSTEP LEG_LEN TURN_SPEED ]:number
@persist [ BODYANG ]:angle
@persist Spin SpinSound Gun:array
@persist Missile:table CanFire
@persist JUMPING BEGINJUMP
@model models/sprops/cuboids/height12/size_3/cube_36x36x12.mdl

#exit()

if( first( ) ) {
    
    # Variables - normal speed, slow
    ##[
    SPEED = 150
    SHIFTSPEED = 10
    LEGSPEED = 1.5
    STEPDAMP = 1
    STEPARCH = 2
    LEGINCREMENT = 0.035
    MAX_OVERSTEP = 135
    BODYHEIGHT = 80
    TURN_SPEED = 45
    LEG_LEN = 100.8
    #]#
    
    # Variables - faster, kinda goofy looking, little buggy over outside corners
    #[
    SPEED = 250
    SHIFTSPEED = 10
    LEGSPEED = 0.6
    STEPDAMP = 1
    STEPARCH = 2
    LEGINCREMENT = 0.1
    MAX_OVERSTEP = 120
    BODYHEIGHT = 70
    TURN_SPEED = 30
    LEG_LEN = 100.8
    ]#
    Body = entity()
    Body:setMass( 50000 )
    #Body:propGravity( 0 )
    
    # Async functions
    function void async( T, F:string ) { 
        timer( format( "cb:%.0f:%s:null:%s", randint( 1e15 ), F, vonEncode( array( ) ) ), T * 1000 ) 
    }
    
    function void async( T, F:string, X:entity ) { 
        timer( format( "cb:%.0f:%s:e:%s",    randint( 1e15 ), F, vonEncode( array( X ) ) ), T * 1000 ) 
    }
    
    function void async(T, F:string, X:number ) {
        timer( format( "cb:%.0f:%s:n:%s", randint( 1e15 ), F, vonEncode( array( X ) ) ), T * 1000 ) 
    }
    
    # Holo data
    Hologram = table()
    Hologram[ "model", array ] = array("models/holograms/hq_sphere.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/props_combine/combinethumper001a.mdl","models/props_combine/combinethumper001a.mdl","models/props_combine/combinethumper001a.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/props_combine/combinethumper001a.mdl","models/props_combine/combinethumper001a.mdl","models/props_combine/combinethumper001a.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/props_combine/combinethumper001a.mdl","models/props_combine/combinethumper001a.mdl","models/props_combine/combinethumper001a.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/props_combine/combinethumper001a.mdl","models/props_combine/combinethumper001a.mdl","models/props_combine/combinethumper001a.mdl","models/holograms/cube.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/cube.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/sprops/trans/exhaust/tip_1.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_cylinder.mdl","models/props_interiors/refrigerator01a.mdl","models/props_interiors/refrigerator01a.mdl","models/props_interiors/refrigerator01a.mdl","models/props_interiors/refrigerator01a.mdl","models/props_interiors/refrigerator01a.mdl","models/holograms/cube.mdl","models/props_c17/playground_jungle_gym01a.mdl","models/props_c17/playground_jungle_gym01b.mdl","models/props_c17/playground_jungle_gym01b.mdl","models/props_c17/furniturecouch001a.mdl","models/holograms/hq_sphere.mdl","models/sprops/misc/alphanum/alphanum_arrow_a.mdl","models/sprops/misc/alphanum/alphanum_arrow_a.mdl","models/sprops/misc/alphanum/alphanum_arrow_a.mdl","models/sprops/misc/alphanum/alphanum_arrow_a.mdl")
    Hologram[ "position", array ] = array(vec(0,0,32),vec(20,20,42),vec(20,20,42),vec(20,20,142.7998),vec(20,20,243.6006),vec(20,20,344.3994),vec(20,20,42),vec(20,20,142.7998),vec(20,20,243.6006),vec(0,0,0),vec(20,27.7998,102),vec(20,27.7998,120.5498),vec(20,27.7998,102),vec(20,27.7998,182.7998),vec(20,27.7998,160.0498),vec(20,27.7998,182.7998),vec(20,27.7998,202),vec(20,27.7998,220.5498),vec(20,27.7998,202),vec(20,27.7998,282.7998),vec(20,27.7998,260.0498),vec(20,27.7998,282.7998),vec(-20,20,42),vec(-20,20,42),vec(-20,20,142.7998),vec(-20,20,243.6006),vec(-20,20,344.3994),vec(-20,20,42),vec(-20,20,142.7998),vec(-20,20,243.6006),vec(0,0,0),vec(-20,27.7998,102),vec(-20,27.7998,120.5498),vec(-20,27.7998,102),vec(-20,27.7998,182.7998),vec(-20,27.7998,160.0498),vec(-20,27.7998,182.7998),vec(-20,27.7998,202),vec(-20,27.7998,220.5498),vec(-20,27.7998,202),vec(-20,27.7998,282.7998),vec(-20,27.7998,260.0498),vec(-20,27.7998,282.7998),vec(20,-20,42),vec(20,-20,42),vec(20,-20,142.7998),vec(20,-20,243.6006),vec(20,-20,344.3994),vec(20,-20,42),vec(20,-20,142.7998),vec(20,-20,243.6006),vec(0,0,0),vec(20,-12.2002,102),vec(20,-12.2002,120.5498),vec(20,-12.2002,102),vec(20,-12.2002,182.7998),vec(20,-12.2002,160.0498),vec(20,-12.2002,182.7998),vec(20,-12.2002,202),vec(20,-12.2002,220.5498),vec(20,-12.2002,202),vec(20,-12.2002,282.7998),vec(20,-12.2002,260.0498),vec(20,-12.2002,282.7998),vec(-20,-20,42),vec(-20,-20,42),vec(-20,-20,142.7998),vec(-20,-20,243.6006),vec(-20,-20,344.3994),vec(-20,-20,42),vec(-20,-20,142.7998),vec(-20,-20,243.6006),vec(0,0,0),vec(-20,-12.2002,102),vec(-20,-12.2002,120.5498),vec(-20,-12.2002,102),vec(-20,-12.2002,182.7998),vec(-20,-12.2002,160.0498),vec(-20,-12.2002,182.7998),vec(-20,-12.2002,202),vec(-20,-12.2002,220.5498),vec(-20,-12.2002,202),vec(-20,-12.2002,282.7998),vec(-20,-12.2002,260.0498),vec(-20,-12.2002,282.7998),vec(36,-6,30),vec(54.4434,-6,28),vec(54.4434,-4,30),vec(54.4434,-8,30),vec(54.4434,-6,32),vec(54.4434,-4.5,28.5),vec(54.4434,-4.5,31.5),vec(54.4434,-7.5,31.5),vec(54.4434,-7.5,28.5),vec(39.2422,-6,30),vec(43.0459,-6,30),vec(67.9707,-6,30),vec(66.7695,-6,30),vec(65.5181,-6,30),vec(36,6,30),vec(54.4434,6,28),vec(54.4434,8,30),vec(54.4434,4,30),vec(54.4434,6,32),vec(54.4434,7.5,28.5),vec(54.4434,7.5,31.5),vec(54.4434,4.5,31.5),vec(54.4434,4.5,28.5),vec(39.2422,6,30),vec(43.0459,6,30),vec(67.9707,6,30),vec(66.7695,6,30),vec(65.5181,6,30),vec(0,-2.0718,71),vec(0,0,71),vec(0,2.168,71),vec(0,-4.1704,71),vec(0,4.1704,71),vec(0.5,0,65.873),vec(-22,0,47),vec(-32,0,50),vec(-32,0,50),vec(-22.8518,0.6008,86.9424),vec(100,0,0),vec(82,0,0),vec(118,0,0),vec(100,-18,0),vec(100,18,0))
    Hologram[ "angle", array ] = array(ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,180,0),ang(0,180,0),ang(0,180,0),ang(0,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,180,0),ang(0,180,0),ang(0,180,0),ang(0,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,180,0),ang(0,180,0),ang(0,180,0),ang(0,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,180,0),ang(0,180,0),ang(0,180,0),ang(0,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(-90,90,0),ang(0,-90,0),ang(90,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(-60.5,0.0353,0),ang(-60.5,0.0353,0),ang(-60.5,0.0353,0),ang(-60.5,0.0353,0),ang(-60.5,0.0353,0),ang(90,0,0),ang(0,0,0),ang(0,90,0),ang(0,-90,0),ang(0,0,0),ang(90,0,0),ang(0,90,90),ang(0,-90,90),ang(0,-180,90),ang(0,0,90))
    Hologram[ "scale", array ] = array(vec(6.5,6.5,6.5),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.2174,0.1547,0.2007),vec(0.2174,0.1547,0.2007),vec(0.2174,0.1547,0.2007),vec(0.0504,0.0504,0.0504),vec(0.45,0.1,0.1),vec(0.4583,0.4583,2.5),vec(0.8333,0.8333,0.5),vec(0.1,0.1,0.1),vec(0.3333,0.3333,3.7917),vec(0.8333,0.8333,0.5),vec(0.45,0.1,0.1),vec(0.4583,0.4583,2.5),vec(0.8333,0.8333,0.5),vec(0.1,0.1,0.1),vec(0.3333,0.3333,3.7917),vec(0.8333,0.8333,0.5),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.2174,0.1547,0.2007),vec(0.2174,0.1547,0.2007),vec(0.2174,0.1547,0.2007),vec(0.0504,0.0504,0.0504),vec(0.45,0.1,0.1),vec(0.4583,0.4583,2.5),vec(0.8333,0.8333,0.5),vec(0.1,0.1,0.1),vec(0.3333,0.3333,3.7917),vec(0.8333,0.8333,0.5),vec(0.45,0.1,0.1),vec(0.4583,0.4583,2.5),vec(0.8333,0.8333,0.5),vec(0.1,0.1,0.1),vec(0.3333,0.3333,3.7917),vec(0.8333,0.8333,0.5),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.2174,0.1547,0.2007),vec(0.2174,0.1547,0.2007),vec(0.2174,0.1547,0.2007),vec(0.0504,0.0504,0.0504),vec(0.45,0.1,0.1),vec(0.4583,0.4583,2.5),vec(0.8333,0.8333,0.5),vec(0.1,0.1,0.1),vec(0.3333,0.3333,3.7917),vec(0.8333,0.8333,0.5),vec(0.45,0.1,0.1),vec(0.4583,0.4583,2.5),vec(0.8333,0.8333,0.5),vec(0.1,0.1,0.1),vec(0.3333,0.3333,3.7917),vec(0.8333,0.8333,0.5),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.0202,0.0202,0.0202),vec(0.2174,0.1547,0.2007),vec(0.2174,0.1547,0.2007),vec(0.2174,0.1547,0.2007),vec(0.0504,0.0504,0.0504),vec(0.45,0.1,0.1),vec(0.4583,0.4583,2.5),vec(0.8333,0.8333,0.5),vec(0.1,0.1,0.1),vec(0.3333,0.3333,3.7917),vec(0.8333,0.8333,0.5),vec(0.45,0.1,0.1),vec(0.4583,0.4583,2.5),vec(0.8333,0.8333,0.5),vec(0.1,0.1,0.1),vec(0.3333,0.3333,3.7917),vec(0.8333,0.8333,0.5),vec(0.1,0.1,0.1),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(0.5,0.5,0.5),vec(0.5,0.5,0.05),vec(0.5,0.5,0.05),vec(0.5,0.5,0.05),vec(0.5,0.5,0.05),vec(0.1,0.1,0.1),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(5,0.4,0.4),vec(0.5,0.5,0.5),vec(0.5,0.5,0.05),vec(0.5,0.5,0.05),vec(0.5,0.5,0.05),vec(0.5,0.5,0.05),vec(0.8244,0.067,0.1226),vec(0.8244,0.067,0.1226),vec(0.8244,0.067,0.1226),vec(0.8244,0.067,0.1226),vec(0.8244,0.067,0.1226),vec(1.2,1.2,1.2),vec(0.8075,0.3,0.3216),vec(0.3,0.3,0.3),vec(0.3,0.3,0.3),vec(0.6,0.6,0.6),vec(0.01,0.2,0.2),vec(1,0.1,1.32),vec(1,0.1,1.32),vec(1,0.1,1.32),vec(1,0.1,1.32))
    Hologram[ "color", array ] = array(vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(250,250,250),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(150,150,150),vec(255,255,255),vec(250,250,250),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(250,250,250),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(150,150,150),vec(255,255,255),vec(250,250,250),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(250,250,250),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(150,150,150),vec(255,255,255),vec(250,250,250),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(250,250,250),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(150,150,150),vec(255,255,255),vec(250,250,250),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(150,150,150),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(125,125,125),vec(125,125,125),vec(125,125,125),vec(125,125,125),vec(125,125,125),vec(75,75,75),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,0,0),vec(255,0,0),vec(255,0,0),vec(255,0,0),vec(255,0,0))
    Hologram[ "alpha", array ] = array(255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255)
    Hologram[ "material", array ] = array("models/props_combine/combinethumper002","","","","","","","","","","","sprops/trans/misc/ls_m1","models/props_combine/combinethumper002","phoenix_storms/fender_chrome","phoenix_storms/fender_chrome","models/props_combine/combinethumper002","","sprops/trans/misc/ls_m1","models/props_combine/combinethumper002","phoenix_storms/fender_chrome","phoenix_storms/fender_chrome","models/props_combine/combinethumper002","","","","","","","","","","","sprops/trans/misc/ls_m1","models/props_combine/combinethumper002","phoenix_storms/fender_chrome","phoenix_storms/fender_chrome","models/props_combine/combinethumper002","","sprops/trans/misc/ls_m1","models/props_combine/combinethumper002","phoenix_storms/fender_chrome","phoenix_storms/fender_chrome","models/props_combine/combinethumper002","","","","","","","","","","","sprops/trans/misc/ls_m1","models/props_combine/combinethumper002","phoenix_storms/fender_chrome","phoenix_storms/fender_chrome","models/props_combine/combinethumper002","","sprops/trans/misc/ls_m1","models/props_combine/combinethumper002","phoenix_storms/fender_chrome","phoenix_storms/fender_chrome","models/props_combine/combinethumper002","","","","","","","","","","","sprops/trans/misc/ls_m1","models/props_combine/combinethumper002","phoenix_storms/fender_chrome","phoenix_storms/fender_chrome","models/props_combine/combinethumper002","","sprops/trans/misc/ls_m1","models/props_combine/combinethumper002","phoenix_storms/fender_chrome","phoenix_storms/fender_chrome","models/props_combine/combinethumper002","","","","","","","","","","WTP/carbonfibre_2","WTP/carbonfibre_2","WTP/carbonfibre_2","WTP/carbonfibre_2","WTP/carbonfibre_2","","","","","","","","","","WTP/carbonfibre_2","WTP/carbonfibre_2","WTP/carbonfibre_2","WTP/carbonfibre_2","WTP/carbonfibre_2","","","","","","models/props_interiors/Radiator01a.mdl","","","","","","","","","")
    Hologram[ "parent", array ] = array(1,1,2,3,4,5,3,4,5,10,3,11,11,4,14,14,4,17,17,5,20,20,1,23,24,25,26,24,25,26,31,24,32,32,25,35,35,25,38,38,26,41,41,1,44,45,46,47,45,46,47,52,45,53,53,46,56,56,46,59,59,47,62,62,1,65,66,67,68,66,67,68,73,66,74,74,67,77,77,67,80,80,68,83,83,1,86,86,86,86,86,86,86,86,86,86,86,86,86,1,100,100,100,100,100,100,100,100,100,100,100,100,100,1,1,1,1,1,1,1,1,1,1,124,124,124,124,124)
    Hologram[ "note", array ] = array("","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","gatlin root right","","","","","","","","","","","","","","gatlin root left","","","","","","","","","","","","","","","","","","","","","","","","","","","","")

    # Holo spawning and setup
    function buffer( ) {
        local Next = Hologram[ "next", number ]
        for( I = Next, Next + clamp( holoRemainingSpawns( ), 0, Hologram[ "model", array ]:count( ) - Next + 1 ) ) {
            holoCreate(
                I,
                entity():toWorld(Hologram["position", array][I, vector]),
                Hologram["scale", array][I, vector],
                entity():toWorld(Hologram["angle", array][I, angle]),
                vec4(Hologram["color", array][I, vector],
                Hologram["alpha", array ][I,number]),
                Hologram["model", array][I, string] #:replace( "models/props_wasteland/cargo_container01.mdl", "models/monk.mdl" )
            )
            holoMaterial(I, Hologram["material", array][I, string])
            holoParent(I, Hologram["parent", array][I, number])
            Hologram[ "next", number ] = I
        }
        if( Next <= Hologram[ "model", array ]:count( ) ) { 
            timer( "buffer", 0.1 ) 
        } else {
            rangerHitEntities( 1 )
            rangerHitWater( 1 )
            propSpawnUndo( 0 )
            Seat = seatSpawn( "models/nova/airboat_seat.mdl", holoEntity( 1 ):toWorld( vec( -24,12,46 ) ), Body:angles( ) - ang( 0, 90, 0 ), 0 )
            Seat:parentTo( holoEntity( 1 ) )
            Seat:setAlpha( 0 )
            Seat:propFreeze( 0 )
            Seat2 = seatSpawn( "models/nova/airboat_seat.mdl", holoEntity( 1 ):toWorld( vec( -24,-12,46 ) ), Body:angles( ) - ang( 0, 90, 0 ), 0 )
            Seat2:parentTo( holoEntity( 1 ) )
            Seat2:setAlpha( 0 )
            Seat2:propFreeze( 0 )
            holoParent( 1, Body )
            holoPos( 1, Body:pos( ) )
            Body:setPos( Body:toWorld( vec( 0, 0, BODYHEIGHT ) ) )
            Body:propFreeze( 1 )
            CanFire = 1
            rangerFilter( Seat )
            rangerFilter( Body )
            rangerPersist( 1 )
            JUMPING = 0
            Body:propFreeze( 0 )
            
            # Turret attach
            async( 1, "moveTurrets" )
            findByClass("gmod_wire_turret")
            local A = findToArray()
            for( I = 1, A:count() ) {
                if( A[I, entity]:owner() == owner() ) {
                    Gun:pushEntity( A[I, entity] )
                }
            }
            function moveTurrets() {
                if(Gun:count() == 2) {
                    Gun[1, entity]:propFreeze( 1 )
                    Gun[1, entity]:setPos( holoEntity( 86 ):pos() + holoEntity( 86 ):forward() * 30 )
                    Gun[1, entity]:setAng( holoEntity( 86 ):angles() - ang( 0, 0, 0 ) )
                    Gun[1, entity]:setAlpha( 0 )
                    Gun[1, entity]:createWire( Body, "Fire", "Fire" )
                    Gun[2, entity]:propFreeze( 1 )
                    Gun[2, entity]:setPos( holoEntity( 100 ):pos() + holoEntity( 100 ):forward() * 30 )
                    Gun[2, entity]:setAng( holoEntity( 100 ):angles() - ang( 0, 0, 0 ) )
                    Gun[2, entity]:setAlpha( 0 )
                    Gun[2, entity]:createWire( Body, "Fire", "Fire" )
                }
                async( 1, "parentTurrets" )
            }
            function parentTurrets() {
                Gun[ 1, entity ]:parentTo( holoEntity( 1 ) )
                Gun[ 2, entity ]:parentTo( holoEntity( 1 ) )
            }
            
            runOnTick( 1 )
        }
    } buffer( )
    
    # Missiles
    function angle incrementedAngle( O:angle, T:angle, S:number ) {
        Ang = acos( O:forward():dot( T:forward() ) )
        if( Ang > S ) { 
            return slerp( quat( O ),quat( T ),S / Ang ):toAngle() 
        } else { 
            return T 
        }
    }
    
    function missilesMove() {
        foreach( K, V:table = Missile ) {
            local MissileEntity = holoEntity( V["iid", number] )
            local MissileTarget = V["target", vector]
            local Ang = incrementedAngle( MissileEntity:angles(), ( MissileTarget - MissileEntity:pos() ):toAngle(), 4 )
            holoAng( V["iid", number], Ang )
            holoPos( V["iid", number], MissileEntity:pos() + ( MissileEntity:forward() * 25 ) )
            if( MissileEntity:pos():distance( MissileTarget ) <= 35 ) {
                Missile:remove( K )
                holoAlpha( V["iid", number], 0 )
                async( 1, "holoDelete", V["iid", number] )
                local X = propSpawn( "models/props_phx/ball.mdl", MissileTarget, ang(), 1 )
                X:propBreak()
            }
        }
    }
    
    function missileFire( Vector:vector ) {
        local IID = 1000 + randint( 2e8 )
        Missile[ IID:toString(), table ] = table( "iid" = IID, "target" = Vector )
        holoCreate( IID, holoEntity( 115 ):pos(), vec(0.25), holoEntity( 115 ):angles(), vec(255), "models/props_phx/amraam.mdl" )
        holoEntity( IID ):setTrails( 0.1, 50, 1, "trails/smoke", vec(75), 255 )
    }
    
    function resetFire() {
        CanFire = 1
    }
    
    # IK 3
    function entity:ik3c( A, B, C, D, LengthA, LengthB, Destination:vector ) {
        local AEntity = holoEntity( A )
        Distance = AEntity:pos():distance( Destination )
        Ae = max( Distance, LengthB )
        Be = LengthA
        Ce = min( Distance, LengthB )
        Calc = sqrt( ( (Ae + Be - Ce + Be) * (-Ae + Be + Ce + Be) * (Ae - Be - Ce + Be) * (Ae + Be - Ce - Be) ) / ( 4 * (Ae - Ce) ^ 2 ) )
        local Arcs = ( sign( Distance - LengthA ) + 1 ) / 2 ? asin( Calc / LengthA ) : acos( Calc / LengthA ) + 90
        local YawAxis = This:toLocalAxis( Destination - AEntity:pos() )
        holoAng( A, This:toWorld( ang( 0, atan( YawAxis:y( ), YawAxis:x( ) ), 0 ) ) )
        holoAng( B, holoEntity( A ):toWorld( ang( 0, -AEntity:bearing( Destination ) - 90, AEntity:elevation( Destination ) + Arcs - 90 ) ) )
        holoAng( C, holoEntity( B ):toWorld( ang( 0, 0, -Arcs ) ) )
        holoAng( D, holoEntity( C ):toWorld( ang( 0, 0, -Arcs ) ) )
    }
    
    # Leg step position / timers
    function fl() {
        FL_P1 = holoEntity( 6 ):pos( )
        FL_P3 = FL_XRD:position( )
        FL_P2 = ( FL_P1 + FL_P3 ) * 0.5 + Body:up() * FL_P1:distance( FL_P3 ) / STEPARCH
        FL_STEP = 0
        if( FL_P1:distance( FL_P3 ) > 35 ) {
            FL_STEP_SOUND = 0
        }
        async( LEGSPEED, "fl" )
    }
    
    function fr() {
        FR_P1 = holoEntity( 48 ):pos( )
        FR_P3 = FR_XRD:position( )
        FR_P2 = ( FR_P1 + FR_P3 ) * 0.5 + Body:up() * FR_P1:distance( FR_P3 ) / STEPARCH
        FR_STEP = 0
        if( FR_P1:distance( FR_P3 ) > 35 ) {
            FR_STEP_SOUND = 0
        }
        async( LEGSPEED, "fr" )
    }
    
    function rl() {
        RL_P1 = holoEntity( 27 ):pos( )
        RL_P3 = RL_XRD:position( )
        RL_P2 = ( RL_P1 + RL_P3 ) * 0.5 + Body:up() * RL_P1:distance( RL_P3 ) / STEPARCH
        RL_STEP = 0
        if( RL_P1:distance( RL_P3 ) > 35 ) {
            RL_STEP_SOUND = 0
        }
        async( LEGSPEED, "rl" )
    }
    
    function rr() {
        RR_P1 = holoEntity( 69 ):pos( )
        RR_P3 = RR_XRD:position( )
        RR_P2 = ( RR_P1 + RR_P3 ) * 0.5 + Body:up() * RR_P1:distance( RR_P3 ) / STEPARCH
        RR_STEP = 0
        if( RR_P1:distance( RR_P3 ) > 35 ) {
            RR_STEP_SOUND = 0
        }
        async( LEGSPEED, "rr" )
    }
    
    local TOffset = LEGSPEED / 4
    async( TOffset * 0, "fr" ) # 0 2 1 3
    async( TOffset * 2, "fl" )
    async( TOffset * 3, "rr" )
    async( TOffset * 1, "rl" )
    
    function entity:stepSound() {
        I = round( random( 1, 7 ) )
        This:soundPlay( holoIndex( This ), soundDuration( "phx/epicmetal_soft" + I + ".wav" ), "phx/epicmetal_soft" + I + ".wav" )
    }
    
    function jumpReset() {
        BEGINJUMP = 0
    }
}

if( clk( "buffer" ) ) { 
    buffer( )
}

if( tickClk( ) ) {
    
    # Controls
    Driver = Seat:driver()
    local Controls = Body:toWorldAxis( 
        vec( 
            Driver:keyForward( ) - Driver:keyBack( ), 
            Driver:keyLeft( ) - Driver:keyRight( ), 
            0
        ) 
    )
    
    Yaw = clamp( round( sin( Body:toLocal( Driver:eyeAngles() ):yaw() ), 3 ) * 2 * TURN_SPEED, -TURN_SPEED, TURN_SPEED )
    if( abs(Yaw) < 10 || !Driver:isValid() ) {
        Yaw = 0
    }
    
    # Easy mount
    if( !Driver:isValid() ) {
        HEIGHT = 40
    } else {
        HEIGHT = BODYHEIGHT
    }
    
    if( Driver:keyJump() ) {
        if( JUMPING == 0 ) {
            Body:applyForce( ( Body:vel():normalized() + Body:up() * 2.5 ) * Body:mass() * 400 )
            JUMPING = 1
            BEGINJUMP = 1
            async( 0.3, "jumpReset" )
        }
    } elseif( Driver:keyWalk() ) {
        HEIGHT = 25
    }
    
    # Rangers
    local V = Body:toWorldAxis( Body:velL( ):normalized( ):setZ( 0 ) * clamp( Body:velL():length() / STEPDAMP, -MAX_OVERSTEP, MAX_OVERSTEP ) )
    RR_XRD = rangerOffset( 250, Body:toWorld( vec( -90, -90, 75 ) ) + V, -Body:up() + -Body:forward() * 0.4 +  Body:right() * 0.4 )
    if( !RR_XRD:hit() ) {
        RR_XRD = rangerOffset( 250, Body:toWorld( vec( -125, -125, 75 ) ) + V, -Body:up() + Body:forward() * 0.25 + -Body:right() * 0.25 )
    }
    RL_XRD = rangerOffset( 250, Body:toWorld( vec( -90,  90, 75 ) ) + V, -Body:up() + -Body:forward() * 0.4 + -Body:right() * 0.4 )
    if( !RL_XRD:hit() ) {
        RL_XRD = rangerOffset( 250, Body:toWorld( vec( -125, 125, 75 ) ) + V, -Body:up() + Body:forward() * 0.25 + Body:right() * 0.25 )
    }
    FR_XRD = rangerOffset( 250, Body:toWorld( vec(  90, -90, 75 ) ) + V, -Body:up() +  Body:forward() * 0.4 +  Body:right() * 0.4 )
    if( !FR_XRD:hit() ) {
        FR_XRD = rangerOffset( 250, Body:toWorld( vec( 125, -125, 75 ) ) + V, -Body:up() + -Body:forward() * 0.25 + -Body:right() * 0.25 )
    }
    FL_XRD = rangerOffset( 250, Body:toWorld( vec(  90,  90, 75 ) ) + V, -Body:up() +  Body:forward() * 0.4 + -Body:right() * 0.4 )
    if( !FL_XRD:hit() ) {
        FL_XRD = rangerOffset( 250, Body:toWorld( vec( 125, 125, 75 ) ) + V, -Body:up() + -Body:forward() * 0.25 + Body:right() * 0.25 )
    }
    
    # Guns
    if( Driver:keyAttack1() ) {
        Spin += 0.1
    } else {
        if( Spin > 0 ) {
            Spin -= 0.1
        }
    }
    Spin = clamp( Spin, 0, 10 )
    if( Spin > 8 ) {
        Fire = 1
    } else {
        Fire = 0
    }
    
    # Missiles
    holoPos( 124, Driver:aimPos() )
    if( Driver:keyAttack2() ) {
        if( Missile:count() < 5 & CanFire == 1 ) {
            if( Driver:aimPos():distance( Body:pos() ) > 1200 ) {
                missileFire( holoEntity( 124 ):pos() )
                CanFire = 0
                async( 1.5, "resetFire" )
            }
        }
    }
    if( Missile:count() > 0 ) {
        missilesMove()
    }
    
    holoAng( 86, holoEntity( 86 ):angles() + ang( 0, 0, Spin ) )
    holoAng( 100, holoEntity( 100 ):angles() + ang( 0, 0, -Spin ) )
    
    # Body angle
    F = (FR_XRD:distance() + FL_XRD:distance()) / 2
    B = (RR_XRD:distance() + RL_XRD:distance()) / 2
    R = (FR_XRD:distance() + RR_XRD:distance()) / 2
    L = (FL_XRD:distance() + RL_XRD:distance()) / 2
    local Torque = vec( R - L, F - B, Yaw )
    Body:applyTorque( ( Torque * Body:inertia() * 33.33 ) - ( Body:angVelVector() * Body:inertia() * 40 ) + Yaw * 10 )
    
    if( JUMPING == 0 ) {
        # Height
        local Mid = ( FR_XRD:position() + FL_XRD:position() + RR_XRD:position() + RL_XRD:position() ) / 4
        local Up = ( Body:pos() - Mid ):normalized() * ( HEIGHT + Body:toLocal(Mid):z() )
        Body:applyForce( Body:mass( ) * Controls * SPEED + Body:mass( ) * tickInterval( ) - Body:mass( ) * Body:vel() + Body:mass( ) * Up * 8 )
        
        if( FR_STEP == 1 & FR_STEP_SOUND == 0 ) {
            holoEntity( 48 ):stepSound()
            Body:setPos( Body:pos() + Body:up() * -3 )
            FR_STEP_SOUND = 1
        }
        if( FL_STEP == 1 & FL_STEP_SOUND == 0 ) {
            holoEntity( 6 ):stepSound()
            Body:setPos( Body:pos() + Body:up() * -3 )
            FL_STEP_SOUND = 1
        }
        if( RR_STEP == 1 & RR_STEP_SOUND == 0 ) {
            holoEntity( 69 ):stepSound()
            Body:setPos( Body:pos() + Body:up() * -3 )
            RR_STEP_SOUND = 1
        }
        if( RL_STEP == 1 & RL_STEP_SOUND == 0 ) {
            holoEntity( 27 ):stepSound()
            Body:setPos( Body:pos() + Body:up() * -3 )
            RL_STEP_SOUND = 1
        }
    } else {
        JXRD = rangerOffset( LEG_LEN * 2, Body:pos(), Body:vel():normalized():setZ( -1 ) )
        if( JXRD:hit() & BEGINJUMP == 0 ) {
            JUMPING = 0
            FR_P1 = FR_P2 = FR_P3 = FR_XRD:position()
            RR_P1 = RR_P2 = RR_P3 = RR_XRD:position()
            RL_P1 = RL_P2 = RL_P3 = RL_XRD:position()
            FL_P1 = FL_P2 = FL_P3 = FL_XRD:position()
            
        }
    }
    
    # Leg movement
    FR_STEP = clamp( FR_STEP + LEGINCREMENT, 0, 1 )
    Body:ik3c( 44, 45, 46, 47, LEG_LEN, LEG_LEN, bezier( FR_P1, FR_P2, FR_P3, FR_STEP ) )
    FL_STEP = clamp( FL_STEP + LEGINCREMENT, 0, 1 )
    Body:ik3c( 2, 3, 4, 5, LEG_LEN, LEG_LEN, bezier( FL_P1, FL_P2, FL_P3, FL_STEP ) )
    RR_STEP = clamp( RR_STEP + LEGINCREMENT, 0, 1 )
    Body:ik3c( 65, 66, 67, 68, LEG_LEN, LEG_LEN, bezier( RR_P1, RR_P2, RR_P3, RR_STEP ) )
    RL_STEP = clamp( RL_STEP + LEGINCREMENT, 0, 1 )
    Body:ik3c( 23, 24, 25, 26, LEG_LEN, LEG_LEN, bezier( RL_P1, RL_P2, RL_P3, RL_STEP ) )
    
    # Hydraulic movement
    HJA1 = ( holoEntity( 14 ):pos() - holoEntity( 11 ):pos() ):toAngle()
    HJA2 = ( holoEntity( 20 ):pos() - holoEntity( 17 ):pos() ):toAngle()
    HJA3 = ( holoEntity( 35 ):pos() - holoEntity( 32 ):pos() ):toAngle()
    HJA4 = ( holoEntity( 41 ):pos() - holoEntity( 38 ):pos() ):toAngle()
    HJA5 = ( holoEntity( 56 ):pos() - holoEntity( 53 ):pos() ):toAngle()
    HJA6 = ( holoEntity( 62 ):pos() - holoEntity( 59 ):pos() ):toAngle()
    HJA7 = ( holoEntity( 77 ):pos() - holoEntity( 74 ):pos() ):toAngle()
    HJA8 = ( holoEntity( 83 ):pos() - holoEntity( 80 ):pos() ):toAngle()
    holoAng( 11, HJA1 )
    holoAng( 14, HJA1 )
    holoAng( 17, HJA2 )
    holoAng( 20, HJA2 )
    holoAng( 32, HJA3 )
    holoAng( 35, HJA3 )
    holoAng( 38, HJA4 )
    holoAng( 41, HJA4 )
    holoAng( 53, HJA5 )
    holoAng( 56, HJA5 )
    holoAng( 59, HJA6 )
    holoAng( 62, HJA6 )
    holoAng( 74, HJA7 )
    holoAng( 77, HJA7 )
    holoAng( 80, HJA8 )
    holoAng( 83, HJA8 )
}

# async
if( clkName( ) != "" && !clk( ) ) {
    local Match = clkName( ):match( "^cb:%d+:([^:]+):([%a%d]+):(.*)$" )
    if( Match:count( ) == 3){
        local F = Match[ 1, string ]
        local R = vonDecode( Match[ 3, string ] )
        switch( Match[ 2, string ] ) {
            case "null", F( ), break
            case "e", F( R[ 1, entity ] ), break
            case "n", F( R[ 1, number ] ), break
        }
        exit()
    }
}







